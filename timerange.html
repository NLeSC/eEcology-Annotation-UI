<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Extjs - Chart</title>
<link rel="stylesheet" href="extjs/resources/css/ext-all.css"
    type="text/css"></link>
<style>
.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.x.axis path {
  display: none;
}

.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.focus {
  fill: none;
  stroke: red;
  stroke-width: 1px;
}

svg {
  background: white;
}

.annotation rect {
  opacity: 0.3;
}

rect.pane {
  cursor: move;
  fill: none;
  pointer-events: all;
}

</style>
<script type="text/javascript" src="extjs/ext-all-dev.js"></script>
<script type="text/javascript" src="d3/d3.min.js"></script>
<script type="text/javascript">

var initDates = [new Date('2010-06-28T00:00:33Z'), new Date('2010-06-29T00:35:33Z')];

Ext.require([
    'Ext.window.Window'
]);

Ext.onReady(function() {
    Ext.define('Esc.d3.accelerometers', {
        extend: 'Ext.Component',
        alias: 'widget.accelchart',
        autoEl: {
            tag: 'svg'
        },
        initComponent: function() {
            this.callParent(arguments);

            this.addEvents(
                'focusDate',
                ''
            );
        },
        onResize: function(width, height, oldWidth, oldHeight) {
            if (oldWidth == undefined && oldHeight == undefined) {
                return;
            }
            this.draw();
        },
        draw: function() {
            var margin = {top: 5, right: 5, bottom: 50, left: 30},
            width = this.getWidth() - margin.left - margin.right,
            height = this.getHeight() - margin.top - margin.bottom;

            this.x.range([0, width]);
            this.y.range([height, 0]);

            var me = this;
            this.svg.select('rect.pane').attr('width', width).attr('height', height);

            this.svg.selectAll('path.line')
                .attr("d", function(d) {
                    return me.line(d.values);
                })
                .style("stroke", function(d) {
                    return me.color(d.name);
                })
            ;

            this.svg.select('g.x.axis')
                .attr("transform", "translate(0," + height + ")")
                .call(this.xAxis);
            this.svg.select('g.y.axis').call(this.yAxis);
            this.svg.select('path.focus').attr("d", d3.svg.line()([[0, 0],[0, height]]));

            this.svg.selectAll(".legend rect").attr("x", width - 18);
            this.svg.selectAll(".legend text").attr("x", width - 24);
        },
        afterRender: function() {
            var me = this;
            var dom = this.getEl().dom;
            var margin = {top: 5, right: 5, bottom: 50, left: 30},
               width = this.getWidth() - margin.left - margin.right,
               height = this.getHeight() - margin.top - margin.bottom;

            var svg = this.svg = d3.select(dom).append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");;

            var x = this.x = d3.time.scale()
               .range([0, width]);

            var y = this.y = d3.scale.linear()
                .range([height, 0]);

            var color = this.color = d3.scale.category10();

            var xAxis = this.xAxis = d3.svg.axis()
                .scale(x)
                .orient("bottom");

            var yAxis = this.yAxis = d3.svg.axis()
                .scale(y)
                .orient("left");

            var line = this.line = d3.svg.line()
                .interpolate("basis")
                .x(function(d) { return x(d.date_time); })
                .y(function(d) { return y(d.g); });

            this.data = [];
            d3.csv("355.2010-06-28.accel0.csv").row(function(d) {
                var dt = new Date(new Date(d.date_time).getTime() + (d.index*30*1000));
                return {
                    date_time: dt,
                    x: +d.x_acceleration,
                    y: +d.y_acceleration,
                    z: +d.z_acceleration,
                  };
            }).get(function(error, rows) {
                me.loadData(rows);
            });

            x.domain(initDates);

            svg.append("g")
                .attr("class", "x axis");

            svg.append("g")
                .attr("class", "y axis")
              .append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 6)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .text("g-force (m/s²)");

            // zoomer rect which captures mouse drags and mouse wheel events
            var zoomer = this.svg.append('rect')
                .attr('class', 'pane')
                .attr('width', width)
                .attr('height', height)
                .on("mouseover", function() { me.focus.style("display", null); })
                .on("mouseout", function() {
                    me.up('window').setTitle('Accelerometers');
                    me.focus.style("display", "none");
                })
                .on("mousemove", this.onMouseMove.bind(this))
                // focus line + zoom dont go together because the compete over mousemove event
                //.call(d3.behavior.zoom().x(x).on("zoom", this.draw.bind(this)))
            ;

            this.focus = svg.append("path")
              .attr("class", "focus")
              .style("display", "none");
        },
        loadData: function(rows) {
            this.data = rows;
            var data = this.data;
            this.svg.datum(this.data);

            this.color.domain(d3.keys(data[0]).filter(function(key) { return key !== "date_time"; }));

            var legend = this.svg.selectAll(".legend")
                .data(this.color.domain())
                .enter().append("g")
                  .attr("class", "legend")
                  .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

          legend.append("rect")
              .attr("width", 18)
              .attr("height", 18)
              .style("fill", this.color);

          legend.append("text")
              .attr("y", 9)
              .attr("dy", ".35em")
              .style("text-anchor", "end")
              .text(function(d) { return d; });

            var cities = this.color.domain().map(function(name) {
              return {
                name: name,
                values: data.map(function(d) {
                  return {date_time: d.date_time, g: +d[name]};
                })
              };
            });
            this.cities = cities;

            this.x.domain(initDates);
            this.y.domain([
              d3.min(cities, function(c) { return d3.min(c.values, function(v) { return v.g; }); }),
              d3.max(cities, function(c) { return d3.max(c.values, function(v) { return v.g; }); })
            ]);

            var city = this.svg.selectAll(".city").data(cities)
            .enter().append("g")
                .attr("class", "city");

            city.append("path")
                .attr("class", "line")
            ;

            this.draw();
        },
        onMouseMove: function() {
            var xp0 = d3.mouse(d3.event.target)[0];
            var x0 = this.x.invert(xp0);
            this.dateFocus(x0);
            this.fireEvent('focusDate', x0);
        },
        dateFocus: function(date) {
            var bisectDate = d3.bisector(function(d) { return d.date_time; }).left;
            var i = bisectDate(this.data, date, 1);
            if (i == 0 || i >= this.data.length) {
                return;
            }
            var d0 = this.data[i - 1];
            var d1 = this.data[i];
            var d = date - d0.date_time > d1.date_time - date ? d1 : d0;
            this.focus.attr("transform", "translate("+ this.x(date) +",0)").style("display", null);
            this.up('window').setTitle('Accelerometers '+d.date_time+', x:'+d3.round(d.x, 5)+', y:'+d3.round(d.y, 5)+', z:'+d3.round(d.z, 5));
        },
        from: function(date) {
            var domain = this.x.domain();
            domain[0] = date;
            this.x.domain(domain);
            this.draw();
        },
        to: function(date) {
            var domain = this.x.domain();
            domain[1] = date;
            this.x.domain(domain);
            this.draw();
        }
    });

    Ext.define('Esc.d3.temperature', {
        extend: 'Ext.Component',
        alias: 'widget.tempchart',
        autoEl: {
            tag: 'svg'
        },
        initComponent: function() {
            this.callParent(arguments);

            this.addEvents(
                'focusDate'
            );
        },
        onResize: function(width, height, oldWidth, oldHeight) {
            if (oldWidth == undefined && oldHeight == undefined) {
                return;
            }
            this.draw();
        },
        draw: function() {
            var margin = {top: 5, right: 5, bottom: 50, left: 30},
            width = this.getWidth() - margin.left - margin.right,
            height = this.getHeight() - margin.top - margin.bottom;

            this.x.range([0, width]);
            this.y.range([height, 0]);

            this.svg.select('rect.pane').attr('width', width).attr('height', height);
            this.svg.select('path.line').attr('d', this.line);
            this.svg.select('g.x.axis')
                .attr("transform", "translate(0," + height + ")")
                .call(this.xAxis);
            this.svg.select('g.y.axis').call(this.yAxis);
            this.svg.select('path.focus').attr("d", d3.svg.line()([[0, 0],[0, height]]));
        },
        afterRender: function() {
            var me = this;
            var dom = this.getEl().dom;
            var margin = {top: 5, right: 5, bottom: 50, left: 30},
               width = this.getWidth() - margin.left - margin.right,
               height = this.getHeight() - margin.top - margin.bottom;

            var svg = this.svg = d3.select(dom).append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");;

            var x = this.x = d3.time.scale()
               .range([0, width]);

            var y = this.y = d3.scale.linear()
                .range([height, 0]);

            var xAxis = this.xAxis = d3.svg.axis()
                .scale(x)
                .orient("bottom");

            var yAxis = this.yAxis = d3.svg.axis()
                .scale(y)
                .orient("left");

            var line = this.line = d3.svg.line()
                .interpolate("basis")
                .x(function(d) { return x(d.date_time); })
                .y(function(d) { return y(d.temperature); });

            this.data = [];
            d3.csv("355.2010-06-28.csv").row(function(d) {
                return {
                    date_time: new Date(d.date_time),
                    temperature: +d.temperature
                  };
            }).get(function(error, rows) {
                me.loadData(rows);
            });

            x.domain(initDates);

            svg.append("g")
                .attr("class", "x axis");

            svg.append("g")
                .attr("class", "y axis")
              .append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 6)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .text("Temperature (ºC)");

            svg.append("path")
                .attr("class", "line");

            // zoomer rect which captures mouse drags and mouse wheel events
            var zoomer = this.svg.append('rect')
                .attr('class', 'pane')
                .attr('width', width)
                .attr('height', height)
                .on("mouseover", function() { me.focus.style("display", null); })
                .on("mouseout", function() {
                    me.up('window').setTitle('Temperature');
                    me.focus.style("display", "none");
                })
                .on("mousemove", this.onMouseMove.bind(this))
                // focus line + zoom dont go together because the compete over mousemove event
                //.call(d3.behavior.zoom().x(x).on("zoom", this.draw.bind(this)))
            ;

            this.focus = svg.append("path")
              .attr("class", "focus")
              .style("display", "none")
            ;


        },
        loadData: function(rows) {
            this.data = rows;
            this.svg.datum(this.data);
            this.y.domain(d3.extent(this.data, function(d) { return d.temperature; }));
            this.draw();
        },
        onMouseMove: function() {
            var xp0 = d3.mouse(d3.event.target)[0];
            var x0 = this.x.invert(xp0);
            this.dateFocus(x0);
            this.fireEvent('focusDate', x0);
        },
        dateFocus: function(date) {
            var bisectDate = d3.bisector(function(d) { return d.date_time; }).left,
            i = bisectDate(this.data, date, 1),
            d0 = this.data[i - 1],
            d1 = this.data[i],
            d = date - d0.date_time > d1.date_time - date ? d1 : d0;
            this.focus.attr("transform", "translate("+ this.x(date) +",0)").style("display", null);
            this.up('window').setTitle('Temperature '+d.date_time+', '+d3.round(d.temperature, 5)+'&deg;C');
        },
        from: function(date) {
            var domain = this.x.domain();
            domain[0] = date;
            this.x.domain(domain);
            this.draw();
        },
        to: function(date) {
            var domain = this.x.domain();
            domain[1] = date;
            this.x.domain(domain);
            this.draw();
        }
    });

    Ext.define('Esc.eEcology.Annotation', {
        extend: 'Ext.data.Model',
        fields: [{
            name: 'type'
        }, {
            name: 'start', type: 'date'
        }, {
            name: 'end', type: 'date'
        }, {
            name: 'color'
        }]
    });

    Ext.define('Esc.eEcology.AnnotationStore', {
        extend: 'Ext.data.Store',
        model: 'Esc.eEcology.Annotation'
    });

    var store = Ext.create('Esc.eEcology.AnnotationStore', {
        listeners: {
            update: function(s, r, o) {
                if (o == Ext.data.Model.COMMIT) {
                    // TODO draw annotation backgrounds on charts
                    var charts = [
                        Ext.ComponentQuery.query('tempchart')[0],
                        Ext.ComponentQuery.query('accelchart')[0]
                    ];
                    charts.forEach(function(c) {
                        var x = c.x(new Date(r.data.start));
                        var w = c.x(new Date(r.data.end))-x;
                        c.svg.insert("g", ':first-child').attr('class', 'annotation').append('rect')
                            .attr('class', r.data.type)
                            .attr('width', w)
                            .attr('height', c.getHeight())
                            .attr('x', x)
                            .attr('y', 0)
                            .style('fill', 'yellow')
                        ;
                    });
                }
            }
        }
    });

    var rowEditing = Ext.create('Ext.grid.plugin.RowEditing', {
        clicksToMoveEditor: 1,
        autoCancel: false
    });

    var agrid = Ext.create('Ext.grid.Panel', {
        store: store,
        columns: [{
            text: 'Type', dataIndex: 'type',
            editor: {xtype: 'combo', allowBlank: false, store:['flying', 'sitting', 'walking', 'floating']}
        }, {
            text: 'Start', dataIndex: 'start',
            editor: {xtype: 'textfield', allowBlank: false}
        }, {
            text: 'End', dataIndex: 'end',
            editor: {xtype: 'textfield', allowBlank: false}
        }, {
            text: 'Color', dataIndex: 'color',
            editor: {xtype: 'textfield', allowBlank: false}
        }],
        plugins: [rowEditing],
        tbar: [{
            text: 'Add annotation',
            handler : function() {
                rowEditing.cancelEdit();

                // Create a model instance
                var r = Ext.create('Esc.eEcology.Annotation', {
                    type: 'walking',
                    start: new Date(1359539768831+(1000*60*60*2)),
                    end: new Date(1359539768831+(1000*60*60*7)),
                    color: 'lightpurple'
                });

                store.insert(0, r);
                rowEditing.startEdit(0, 0);
            }
        }],
        listeners: {
            edit: function(editor, e) {
                e.record.commit();
            }
        },
    });

    var awin = Ext.create('Ext.window.Window', {
        x: 840,
        y: 20,
        width : 400,
        height : 300,
        autoShow: true,
        title : 'Annotations',
        layout: 'fit',
        maximizable: true,
        items: [agrid]
    })

    var awin = Ext.create('Ext.window.Window', {
        x: 840,
        y: 400,
        width : 400,
        height : 300,
        autoShow: true,
        title : 'Timeline',
        layout: 'fit',
        maximizable: true,
        items: {
            xtype: 'form',
            defaults: {
                xtype: 'textfield',
                width: 340,
                labelAlign: 'top'
            },
            items: [{
                fieldLabel: 'From',
                name: 'from_date',
                value: initDates[0],
                listeners: {
                    change: function(t, n, o) {
                        var date = new Date(n);
                        Ext.ComponentQuery.query('accelchart')[0].from(date);
                        Ext.ComponentQuery.query('tempchart')[0].from(date);
                    }
                }
            }, {
                fieldLabel: 'To',
                name: 'to_date',
                value: initDates[1],
                listeners: {
                    change: function(t, n, o) {
                        var date = new Date(n);
                        Ext.ComponentQuery.query('accelchart')[0].to(date);
                        Ext.ComponentQuery.query('tempchart')[0].to(date);
                    }
                }
            }, {
                fieldLabel: 'Current',
                name: 'current_date',
                listeners: {
                    change: function(t, n, o) {
                        var date = new Date(n);
                        Ext.ComponentQuery.query('accelchart')[0].dateFocus(date);
                        Ext.ComponentQuery.query('tempchart')[0].dateFocus(date);
                    }
                }
            }]
        }
    })

    var win = Ext.create('Ext.window.Window', {
        x: 20,
        y: 20,
        width : 800,
        height : 300,
        title : 'Temperature',
        layout: 'fit',
        maximizable: true,
        autoShow: true,
        items: [{
            xtype: 'tempchart',
            listeners: {
                focusDate: function(date) {
                    Ext.ComponentQuery.query('accelchart')[0].dateFocus(date);
                    Ext.ComponentQuery.query('component[name=current_date]')[0].setValue(date);
                }
            }
        }]
    })

    var win2 = Ext.create('Ext.window.Window', {
        x: 20,
        y: 400,
        width : 800,
        height : 300,
        title : 'Accelerometers',
        layout: 'fit',
        maximizable: true,
        autoShow: true,
        items: [{
            xtype: 'accelchart',
            listeners: {
                focusDate: function(date) {
                    Ext.ComponentQuery.query('tempchart')[0].dateFocus(date);
                    Ext.ComponentQuery.query('component[name=current_date]')[0].setValue(date);
                }
            }
        }]
    })
});
</script>
</head>
<body>
</body>
</html>