<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Extjs - Chart</title>
<link rel="stylesheet" href="extjs/resources/css/ext-all.css"
    type="text/css"></link>
<link rel="stylesheet" type="text/css" href="ext-js-google-earth-api/Ext.ux.GEarthPanel-1.3.css" />
<style>
.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.focus {
  fill: none;
  stroke: red;
  stroke-width: 2px;
}

.scrubber {
  fill: darkred;
  stroke: red;
  cursor: pointer;
  stroke-width: 2px;
}


svg {
  background: white;
  font: 10px sans-serif;
}

path {
  fill: steelblue;
}

.annotation rect {
  opacity: 0.3;
}

.brush .extent {
  stroke: #fff;
  fill-opacity: .125;
  shape-rendering: crispEdges;
}

rect.pane {
  cursor: move;
  fill: none;
  pointer-events: all;
}
.play {
  background-image: url(famfamfam_silk_icons/icons/control_play.png) !important;
}

.pause {
  background-image: url(famfamfam_silk_icons/icons/control_pause.png) !important;
}

.rewind {
  background-image: url(famfamfam_silk_icons/icons/control_rewind.png) !important;
}

video {
	background: black;
}

</style>
<script type="text/javascript" src="extjs/ext-all-dev.js"></script>
<script type="text/javascript" src="d3/d3.min.js"></script>
<script type="text/javascript" src="https://www.google.com/jsapi"></script>
<!-- http://popcornjs.org/code/dist/popcorn-complete.min.js -->
<script type="text/javascript" src="popcorn-complete.js"></script>
<script type="text/javascript">
google.load("earth", "1");
google.load("maps", "2.xx");

Ext.Loader.setConfig({
    enabled: true,
    disableCaching: false, // uncomment to use firebug breakpoints
    paths: {
      'Ext.ux': 'ux/'
    }
});

Ext.require([
    'Ext.window.Window',
    'Ext.ux.GEarthPanel'
]);

Ext.useShims = true;

Ext.onReady(function() {
    var initDates = [new Date('2010-06-28T00:00:33Z'), new Date('2010-06-29T00:35:33Z')];
    function timeFormat(formats) {
        return function(date) {
          var i = formats.length - 1, f = formats[i];
          while (!f[1](date)) f = formats[--i];
          return f[0](date);
        };
      }

    var customTimeFormat = timeFormat([
                                       [d3.time.format("%Y"), function() { return true; }],
                                       [d3.time.format("%B"), function(d) { return d.getMonth(); }],
                                       [d3.time.format("%b %d"), function(d) { return d.getDate() != 1; }],
                                       [d3.time.format("%x"), function(d) { return d.getDay() && d.getDate() != 1; }],
                                       [d3.time.format("%H:%M"), function(d) { return d.getHours(); }],
                                       [d3.time.format("%H:%M"), function(d) { return d.getMinutes(); }],
                                       [d3.time.format(":%S"), function(d) { return d.getSeconds(); }],
                                       [d3.time.format(".%L"), function(d) { return d.getMilliseconds(); }]
                                     ]);


    Ext.define('Esc.d3.accelerometers', {
        extend: 'Ext.Component',
        alias: 'widget.accelchart',
        autoEl: {
            tag: 'svg'
        },
        initComponent: function() {
        	this.callParent(arguments);

            this.addEvents(
            	'focusDate'
            );
        },
        onResize: function(width, height, oldWidth, oldHeight) {
            if (oldWidth == undefined && oldHeight == undefined) {
                return;
            }
            this.draw();
        },
        draw: function() {
            var margin = {top: 5, right: 5, bottom: 50, left: 30},
            width = this.getWidth() - margin.left - margin.right,
            height = this.getHeight() - margin.top - margin.bottom;

            this.x.range([0, width]);
            this.y.range([height, 0]);

            var me = this;
            this.svg.select('rect.pane').attr('width', width).attr('height', height);

            this.svg.selectAll('path.line')
	            .attr("d", function(d) {
	                return me.line(d.values);
	            })
	            .style("stroke", function(d) {
	                return me.color(d.name);
	            })
	        ;

            this.svg.select('g.x.axis')
                .attr("transform", "translate(0," + height + ")")
                .call(this.xAxis);
            this.svg.select('g.y.axis').call(this.yAxis);
            this.svg.select('path.focus').attr("d", d3.svg.line()([[0, 0],[0, height]]));

            this.svg.selectAll(".legend rect").attr("x", width - 18);
            this.svg.selectAll(".legend text").attr("x", width - 24);
        },
        afterRender: function() {
            var me = this;
            var dom = this.getEl().dom;
            var margin = {top: 5, right: 5, bottom: 50, left: 30},
               width = this.getWidth() - margin.left - margin.right,
               height = this.getHeight() - margin.top - margin.bottom;

            var svg = this.svg = d3.select(dom).append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");;

            var x = this.x = d3.time.scale()
               .range([0, width]);

            var y = this.y = d3.scale.linear()
                .range([height, 0]);

            var color = this.color = d3.scale.category10();

            var xAxis = this.xAxis = d3.svg.axis()
                .scale(x).tickFormat(customTimeFormat)
                .orient("bottom");

            var yAxis = this.yAxis = d3.svg.axis()
                .scale(y)
                .orient("left");

            var line = this.line = d3.svg.line()
	            .interpolate("basis")
	            .x(function(d) { return x(d.date_time); })
	            .y(function(d) { return y(d.g); });

	        this.data = [];
	        d3.csv("355.2010-06-28.accel0.csv").row(function(d) {
	            var dt = new Date(new Date(d.date_time).getTime() + (d.index*30*1000));
	            return {
	                date_time: dt,
	                x: +d.x_acceleration,
	                y: +d.y_acceleration,
	                z: +d.z_acceleration,
	              };
	        }).get(function(error, rows) {
	            me.loadData(rows);
	        });

	        x.domain(initDates);

	        svg.append("g")
	            .attr("class", "x axis");

	        svg.append("g")
	            .attr("class", "y axis")
	          .append("text")
	            .attr("transform", "rotate(-90)")
	            .attr("y", 6)
	            .attr("dy", ".71em")
	            .style("text-anchor", "end")
	            .text("g-force (m/s²)");

	        // zoomer rect which captures mouse drags and mouse wheel events
	        var zoomer = this.svg.append('rect')
	            .attr('class', 'pane')
	            .attr('width', width)
	            .attr('height', height)
	            //.on("mouseover", function() { me.focus.style("display", null); })
	            //.on("mouseout", function() {
//	                me.up('window').setTitle('Accelerometers');
	//                me.focus.style("display", "none");
	  //          })
	            //.on("mousemove", this.onMouseMove.bind(this))
	            // focus line + zoom dont go together because the compete over mousemove event
	            //.call(d3.behavior.zoom().x(x).on("zoom", this.draw.bind(this)))
	        ;

	        this.focus = svg.append("path")
	          .attr("class", "focus")
	          .style("display", "none");
	    },
	    loadData: function(rows) {
	        this.data = rows;
	        var data = this.data;
	        this.svg.datum(this.data);

	        this.color.domain(d3.keys(data[0]).filter(function(key) { return key !== "date_time"; }));

	        var legend = this.svg.selectAll(".legend")
	            .data(this.color.domain())
	            .enter().append("g")
	              .attr("class", "legend")
	              .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

	      legend.append("rect")
	          .attr("width", 18)
	          .attr("height", 18)
	          .style("fill", this.color);

	      legend.append("text")
	          .attr("y", 9)
	          .attr("dy", ".35em")
	          .style("text-anchor", "end")
	          .text(function(d) { return d; });

	        var cities = this.color.domain().map(function(name) {
	          return {
	            name: name,
	            values: data.map(function(d) {
	              return {date_time: d.date_time, g: +d[name]};
	            })
	          };
	        });
	        this.cities = cities;

	        this.x.domain(initDates);
	        this.y.domain([
	          d3.min(cities, function(c) { return d3.min(c.values, function(v) { return v.g; }); }),
	          d3.max(cities, function(c) { return d3.max(c.values, function(v) { return v.g; }); })
	        ]);

	        var city = this.svg.selectAll(".city").data(cities)
	        .enter().append("g")
	            .attr("class", "city");

	        city.append("path")
	            .attr("class", "line")
	        ;

	        this.draw();
	    },
	    onMouseMove: function() {
	        var xp0 = d3.mouse(d3.event.target)[0];
	        var x0 = this.x.invert(xp0);
	        this.dateFocus(x0);
	        this.fireEvent('focusDate', x0);
	    },
	    dateFocus: function(date) {
	        var bisectDate = d3.bisector(function(d) { return d.date_time; }).left;
	        var i = bisectDate(this.data, date, 1);
	        if (i == 0 || i >= this.data.length) {
	            return;
	        }
	        var d0 = this.data[i - 1];
	        var d1 = this.data[i];
	        var d = date - d0.date_time > d1.date_time - date ? d1 : d0;
	        this.focus.attr("transform", "translate("+ this.x(date) +",0)").style("display", null);
	        this.up('window').setTitle('Accelerometers '+d.date_time+', x:'+d3.round(d.x, 5)+', y:'+d3.round(d.y, 5)+', z:'+d3.round(d.z, 5));
	    },
	    from: function(date) {
	        var domain = this.x.domain();
	        domain[0] = date;
	        this.x.domain(domain);
	        this.draw();
	    },
	    to: function(date) {
	        var domain = this.x.domain();
	        domain[1] = date;
	        this.x.domain(domain);
	        this.draw();
	    }
    });

	Ext.define('Esc.d3.temperature', {
		extend: 'Ext.Component',
		alias: 'widget.tempchart',
		autoEl: {
            tag: 'svg'
        },
        initComponent: function() {
            this.callParent(arguments);

            this.addEvents(
                'focusDate'
            );
        },
        onResize: function(width, height, oldWidth, oldHeight) {
            if (oldWidth == undefined && oldHeight == undefined) {
                return;
            }
            this.draw();
        },
        draw: function() {
            var margin = {top: 5, right: 5, bottom: 50, left: 30},
            width = this.getWidth() - margin.left - margin.right,
            height = this.getHeight() - margin.top - margin.bottom;

            this.x.range([0, width]);
            this.y.range([height, 0]);

            this.svg.select('rect.pane').attr('width', width).attr('height', height);
            this.svg.select('path.line').attr('d', this.line);
            this.svg.select('g.x.axis')
                .attr("transform", "translate(0," + height + ")")
                .call(this.xAxis);
            this.svg.select('g.y.axis').call(this.yAxis);
            this.svg.select('path.focus').attr("d", d3.svg.line()([[0, 0],[0, height]]));
        },
        afterRender: function() {
        	var me = this;
        	var dom = this.getEl().dom;
        	var margin = {top: 5, right: 5, bottom: 50, left: 30},
        	   width = this.getWidth() - margin.left - margin.right,
        	   height = this.getHeight() - margin.top - margin.bottom;

        	var svg = this.svg = d3.select(dom).append("g")
    			.attr("transform", "translate(" + margin.left + "," + margin.top + ")");;

			var x = this.x = d3.time.scale()
			   .range([0, width]);

			var y = this.y = d3.scale.linear()
			    .range([height, 0]);

			var xAxis = this.xAxis = d3.svg.axis()
			    .scale(x).tickFormat(customTimeFormat)
			    .orient("bottom");

			var yAxis = this.yAxis = d3.svg.axis()
			    .scale(y)
			    .orient("left");

            var line = this.line = d3.svg.line()
	            .interpolate("basis")
	            .x(function(d) { return x(d.date_time); })
	            .y(function(d) { return y(d.temperature); });

	        this.data = [];
	        d3.csv("355.2010-06-28.csv").row(function(d) {
	            return {
	                date_time: new Date(d.date_time),
	                temperature: +d.temperature
	              };
	        }).get(function(error, rows) {
	            me.loadData(rows);
	        });

	        x.domain(initDates);

	        svg.append("g")
	            .attr("class", "x axis");

	        svg.append("g")
	            .attr("class", "y axis")
	          .append("text")
	            .attr("transform", "rotate(-90)")
	            .attr("y", 6)
	            .attr("dy", ".71em")
	            .style("text-anchor", "end")
	            .text("Temperature (ºC)");

	        svg.append("path")
	            .attr("class", "line");

	        // zoomer rect which captures mouse drags and mouse wheel events
	        var zoomer = this.svg.append('rect')
	            .attr('class', 'pane')
	            .attr('width', width)
	            .attr('height', height)
	            //.on("mouseover", function() { me.focus.style("display", null); })
	            //.on("mouseout", function() {
	            //    me.up('window').setTitle('Temperature');
	             //   me.focus.style("display", "none");
	            //})
	           // .on("mousemove", this.onMouseMove.bind(this))
	            // focus line + zoom dont go together because the compete over mousemove event
	            //.call(d3.behavior.zoom().x(x).on("zoom", this.draw.bind(this)))
	        ;

	        this.focus = svg.append("path")
	          .attr("class", "focus")
	          .style("display", "none")
	        ;
	    },
	    loadData: function(rows) {
	        this.data = rows;
	        this.svg.datum(this.data);
	        this.y.domain(d3.extent(this.data, function(d) { return d.temperature; }));
	        this.draw();
	    },
	    onMouseMove: function() {
	        var xp0 = d3.mouse(d3.event.target)[0];
	        var x0 = this.x.invert(xp0);
	        this.dateFocus(x0);
	        this.fireEvent('focusDate', x0);
	    },
	    dateFocus: function(date) {
	        var bisectDate = d3.bisector(function(d) { return d.date_time; }).left,
	        i = bisectDate(this.data, date, 1),
	        d0 = this.data[i - 1],
	        d1 = this.data[i],
	        d = date - d0.date_time > d1.date_time - date ? d1 : d0;
	        this.focus.attr("transform", "translate("+ this.x(date) +",0)").style("display", null);
	        this.up('window').setTitle('Temperature '+d.date_time+', '+d3.round(d.temperature, 5)+'&deg;C');
	    },
	    from: function(date) {
	        var domain = this.x.domain();
	        domain[0] = date;
	        this.x.domain(domain);
	        this.draw();
	    },
	    to: function(date) {
	        var domain = this.x.domain();
	        domain[1] = date;
	        this.x.domain(domain);
	        this.draw();
	    }
	});

	Ext.define('Esc.eEcology.Timeline', {
	    extend: 'Ext.Component',
        alias: 'widget.timeline',
        autoEl: {
            tag: 'svg'
        },
        config: {
            lanes: 4,
            from: initDates[0],
            to: initDates[1],
            current: initDates[0]
        },
        constructor: function(config) {
            this.callParent(arguments);
            this.initConfig(config);
        },
        initComponent: function() {
            this.callParent(arguments);

            this.addEvents('focusDate');
        },
        onResize: function(width, height, oldWidth, oldHeight) {
            if (oldWidth == undefined && oldHeight == undefined) {
                return;
            }
            this.draw();
        },
        afterRender: function() {
            var me = this;
            var dom = this.getEl().dom;
            var margin = {top: 5, right: 5, bottom: 40, left: 30},
               width = this.getWidth() - margin.left - margin.right,
               height = this.getHeight() - margin.top - margin.bottom;

            var svg = this.svg = d3.select(dom).append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            var xScale = this.xScale = d3.time.scale().range([0, width]).domain([this.getFrom(), this.getTo()]);

            var xAxis = this.xAxis = d3.svg.axis().scale(xScale)
                .tickSubdivide(3).tickSize(20, 5, 0)
                .tickFormat(customTimeFormat)
                .orient("bottom");

            svg.append("g").attr("class", "x axis");

            var node_drag = d3.behavior.drag()
            .on("drag", function(d, i) {
                var current = (d3.select(this).attr('cx')*1) + d3.event.dx;
                var currentDate = me.xScale.invert(current);
                Ext.getCmp('current_time').setValue(currentDate);
            })
            ;

            svg.append("circle").attr('r', 7).attr('class', 'scrubber').call(node_drag);
            svg.append("line").attr('class', 'scrubber');

            // example lanes + annotations
            this.yScale = d3.scale.ordinal().rangeRoundBands([0, height]).domain([1,2,3,4]);
            this.yAxis = d3.svg.axis().scale(this.yScale)
                .orient("left").tickSize(5, 0, 0);
            svg.append("g").attr("class", "y axis");

            this.draw();
        },
        dateFocus: function(current) {
            var me = this;
            me.setCurrent(current);
            me.draw();
        },
        draw: function() {
            var me = this;
            var margin = {top: 5, right: 5, bottom: 40, left: 30},
            width = this.getWidth() - margin.left - margin.right,
            height = this.getHeight() - margin.top - margin.bottom;

            this.xScale.range([0, width]);

            this.svg.select('g.x.axis').attr("transform", "translate(0," + height + ")").call(this.xAxis);
            this.svg.select('circle.scrubber').attr('cy', height+12).attr('cx', this.xScale(this.getCurrent()));
            this.svg.select('line.scrubber')
                .attr('x1', this.xScale(me.getCurrent()))
                .attr('y1', 0)
                .attr('x2', this.xScale(me.getCurrent()))
                .attr('y2', height+5);

            this.yScale.rangeRoundBands([0, height]);
            this.svg.select('g.y.axis').call(this.yAxis);

        },
        setFromDate: function(date) {
            this.setFrom(date);
            if (this.xScale == undefined) return;
            var domain = this.xScale.domain();
            domain[0] = date;
            this.xScale.domain(domain);
            this.draw();
        },
        setToDate: function(date) {
            this.setTo(date);
            if (this.xScale == undefined) return;
            var domain = this.xScale.domain();
            domain[1] = date;
            this.xScale.domain(domain);
            this.draw();
        }
	});

	Ext.define('Esc.eEcology.Annotation', {
		extend: 'Ext.data.Model',
		fields: [{
			name: 'type'
		}, {
			name: 'start', type: 'date'
		}, {
			name: 'end', type: 'date'
		}, {
			name: 'color'
        }, {
            name: 'lane'
		}]
	});

	Ext.define('Esc.eEcology.AnnotationStore', {
		extend: 'Ext.data.Store',
		model: 'Esc.eEcology.Annotation'
	});

	var store = Ext.create('Esc.eEcology.AnnotationStore', {
		listeners: {
			dataChanged: function() {
				console.log('Data changed', arguments);
			},
            add: function() {
                console.log('add', arguments);
            },
            remove: function() {
                console.log('remove', arguments);
            },
            clear: function() {
                console.log('clear', arguments);
            },
			update: function(s, r, o) {
				if (o == Ext.data.Model.COMMIT) {
                    var start = new Date(r.data.start);
                    var end = new Date(r.data.end);
				    // TODO draw annotation backgrounds on charts
				    var charts = [
                        Ext.ComponentQuery.query('tempchart')[0],
                        Ext.ComponentQuery.query('accelchart')[0]
				    ];
				    charts.forEach(function(c) {
                        var x = c.x(start);
				    	var w = c.x(end)-x;
				    	// TODO add updating
			            c.svg.insert("g", ':first-child').attr('class', 'annotation').append('rect')
			                .attr('class', r.data.type)
			                .attr('width', w)
			                .attr('height', c.getHeight())
			                .attr('x', x)
			                .attr('y', 0)
			                .style('fill', r.data.color)
			            ;
				    });

				    var timeline = Ext.ComponentQuery.query('timeline')[0];
				    timeline.svg.insert("g", ':first-child').attr('class', 'annotation').append('rect')
	                    .attr('class', r.data.type)
	                    .attr('width', timeline.xScale(end) - timeline.xScale(start))
	                    .attr('height', timeline.yScale.rangeBand())
	                    .attr('x', timeline.xScale(start))
	                    .attr('y', timeline.yScale(r.data.lane))
	                    .style('fill', r.data.color)
	                    .attr('ry', 4).attr('ry', 4)
	                ;

				    var video = Ext.ComponentQuery.query('popcorn')[0];
				    //var s = (video.startDate - start) / 1000;
				    //var e = (video.startDate - end) / 1000;
					var s = 0;
					var e = 120;
				    var sub = video.pop.annotation({
				    	start: s,
				    	end: e,
				    	text: r.data.type,
				    });
				    sub.container.style.color = r.data.color;

				    earth.annotate(r);
				}
			}
		}
	});

	var rowEditing = Ext.create('Ext.grid.plugin.RowEditing', {
        clicksToMoveEditor: 1,
        autoCancel: false
    });

	// There is no datetime field in ExtJS, so use a textfield with ISO 8601 validator
	Ext.apply(Ext.form.field.VTypes, {
	    //  vtype validation function
	    datetime: function(val, field) {
	        return Ext.Date.parse(val, 'c', true) != null;
	    },
	    // vtype Text property: The error text to display when the validation function returns false
	    datetimeText: 'Not a valid date.  Must be in the ISO 8601 date format.',
	    // vtype Mask property: The keystroke filter mask
	    datetimeMask: /[\d\.,-:+TZ]/
	});
	Ext.define('Esc.form.field.DateTime', {
		extend: 'Ext.form.field.Text',
		alias: 'widget.datetimefield',
		vtype: 'datetime',
		valueToRaw: function(value) {
			if (value === undefined) {
				return value;
			}
            return value.toISOString();
		},
		rawToValue: function(raw) {
            return new Date(raw);
		}
	});

    var agrid = Ext.create('Ext.grid.Panel', {
        store: store,
        columns: [{
        	text: 'Type', dataIndex: 'type',
        	editor: {xtype: 'combo', allowBlank: false, store:['flying', 'sitting', 'walking', 'floating']}
        }, {
            text: 'Start', dataIndex: 'start', flex: 1,
            xtype: 'datecolumn', format: 'c',
            editor: {xtype: 'datetimefield', allowBlank: false}
        }, {
            text: 'End', dataIndex: 'end', flex: 1,
            xtype: 'datecolumn', format: 'c',
            editor: {xtype: 'datetimefield', allowBlank: false}
        }, {
            text: 'Color', dataIndex: 'color',
            renderer: function(v, m) {
            	m.style = 'background:'+v+';';
            	return v;
            },
            editor: {xtype: 'textfield', allowBlank: false}
        }, {
            text: 'Lane', dataIndex: 'lane', flex: 1,
            xtype: 'numbercolumn',
            editor: {xtype: 'combo', allowBlank: false, store:[1,2,3,4] }
        }],
        plugins: [rowEditing],
        selModel: {
          mode: 'SINGLE'
        },
        selType: 'checkboxmodel',
        tbar: [{
            text: 'Add annotation',
            handler : function() {
                rowEditing.cancelEdit();

                // Create a model instance
                var r = Ext.create('Esc.eEcology.Annotation', {
                	type: 'walking',
                    start: new Date('2010-06-28T00:12:47Z'),
                    end: new Date('2010-06-28T06:12:47Z'),
                    color: 'rgb(180, 112, 197)',
                    lane: 1
                });

                store.insert(0, r);
                rowEditing.startEdit(0, 0);
            }
        }],
        listeners: {
            edit: function(editor, e) {
                e.record.commit();
            }
        },
    });

    var awin = Ext.create('Ext.window.Window', {
        x: 20,
        y: 540,
        width : 840,
        height : 300,
		closable: false,
        title : 'Annotations',
        layout: 'fit',
        maximizable: true,
        collapsible: true,
        items: [agrid],
    })
    awin.show();

    var twin = Ext.create('Ext.window.Window', {
        x: 880,
        y: 540,
        width : 980,
        height : 300,
        autoShow: true,
        title : 'Timeline',
        layout: 'fit',
        maximizable: true,
        collapsible: true,
        closable: false,
        dockedItems: [{
            xtype: 'toolbar',
            dock: 'bottom',
            defaults: {
                xtype: 'datetimefield',
                width: 170,
                labelAlign: 'top'
            },
            items: [{
                fieldLabel: 'From',
                id: 'from_date',
                value: initDates[0],
                validator: function(value) {
                    var t = Ext.getCmp('to_date').getValue();
                    var c = Ext.getCmp('current_time').getValue();
                    if (value > t) {
                        return 'From must be before To';
                    }
                    return true;
                },
                listeners: {
                    change: function(t, n, o) {
                        var date = new Date(n);
                        Ext.ComponentQuery.query('accelchart')[0].from(date);
                        Ext.ComponentQuery.query('tempchart')[0].from(date);
                        Ext.ComponentQuery.query('timeline')[0].setFromDate(date);

                        // keep current time inside visible range
                        var c = Ext.getCmp('current_time');
                        if (c.getValue() < date) {
                            c.setValue(date);
                        }
                    }
                }
            }, {
                fieldLabel: 'Current',
                id: 'current_time',
                value: initDates[0],
                listeners: {
                    change: function(t, n, o) {
                        var date = new Date(n);
                        Ext.ComponentQuery.query('accelchart')[0].dateFocus(date);
                        Ext.ComponentQuery.query('tempchart')[0].dateFocus(date);
                        Ext.ComponentQuery.query('timeline')[0].dateFocus(date);

                        var earth_time = earth.getEarth().getTime();
                        var t = earth_time.getTimePrimitive();
                        if (t.getType() != 'KmlTimeSpan') {
                            t = earth_time.getControl().getExtents();
                        }
                        t.getEnd().set(date.toISOString());
                        earth_time.setTimePrimitive(t);

                        var video = Ext.ComponentQuery.query('popcorn')[0];
                        var newValue = date.getTime();
                        var minValue = Ext.getCmp('from_date').getValue().getTime();
                        var maxValue = Ext.getCmp('to_date').getValue().getTime();
                        // video is much shorter than data from db
                        // scale video range to visible time range
                        var newct = video.pop.duration() * (newValue-minValue) / (maxValue-minValue);
                        video.pop.currentTime(newct);
                    }
                }
            }, {
                fieldLabel: 'To',
                id: 'to_date',
                value: initDates[1],
                validator: function(value) {
                    var f = Ext.getCmp('from_date').getValue();
                    var c = Ext.getCmp('current_time').getValue();
                    if (value < f) {
                        return 'To must be after From';
                    }
                    return true;
                },
                listeners: {
                    change: function(t, n, o) {
                        var date = new Date(n);
                        Ext.ComponentQuery.query('accelchart')[0].to(date);
                        Ext.ComponentQuery.query('tempchart')[0].to(date);
                        Ext.ComponentQuery.query('timeline')[0].setToDate(date);

                        // keep current time inside visible range
                        var c = Ext.getCmp('current_time');
                        if (c.getValue() > date) {
                            c.setValue(date);
                        }
                    }
                }
            }]
        }],
        items: [{
            xtype: 'timeline',
            listeners: {
                boxready: function(t) {
                   t.draw();
                }
            }
        }]
    })


    var win = Ext.create('Ext.window.Window', {
        x: 20,
        y: 20,
        width : 800,
        height : 240,
		closable: false,
        title : 'Temperature',
        layout: 'fit',
        maximizable: true,
        collapsible: true,
        items: [{
            xtype: 'tempchart',
            listeners: {
            	focusDate: function(date) {
            		//Ext.ComponentQuery.query('accelchart')[0].dateFocus(date);
            	}
            }
        }]
    })
    win.show();

    var win2 = Ext.create('Ext.window.Window', {
    	x: 20,
        y: 280,
        width : 800,
        height : 240,
		closable: false,
        collapsible: true,
        title : 'Accelerometers',
        layout: 'fit',
        maximizable: true,
        items: [{
            xtype: 'accelchart',
            listeners: {
                focusDate: function(date) {
                 //   Ext.ComponentQuery.query('tempchart')[0].dateFocus(date);
                }
            }
        }]
    })
    win2.show();

	// Use https://github.com/pymonger/ext-js-google-earth-api
	earth = Ext.create('Ext.ux.GEarthPanel', {
		earthLayers: {
            LAYER_BUILDINGS: true,
            LAYER_TERRAIN: true
        },
        earthOptions: {
            setStatusBarVisibility: false,
            setAtmosphereVisibility: true,
            setMouseNavigationEnabled: true
        },
        annotate: function(record) {
	        var begin = record.data.start;
	        var end = record.data.end;
	        // Convert rgb(rr, gg, bb) to FFbbggrr
            var color = d3.rgb(record.data.color);
	        var abgr = 'ff'+color.b.toString(16)+color.g.toString(16)+color.r.toString(16);

            // Only the first placemark is shown initially
            // to see all placemarks the time has to be set to a time span
        	// can't set time to whole extent during fetchkml callback
        	// so do it here
            var timespan = this.earth.getTime().getControl().getExtents();
            this.earth.getTime().setTimePrimitive(timespan);

            Ext.Array.forEach(this.placemarks, function(placemark) {
            	var ts_begin = placemark.begin;
            	var ts_end = placemark.end;
            	if (
                        (ts_begin>=begin && ts_begin<=end) ||
                        (ts_end>=begin && ts_end<=end) ||
                        (ts_begin<=begin && ts_end>=end)
                ) {
                    placemark.color.set(abgr);
                }
            });
        }
	});
	var href = 'http://145.100.61.22/workspace4/ExtJS-Cesium/S355_museumplein.kml';

	var earth_options = Ext.create('Ext.window.Window', {
		title: 'Google Earth options',
		width: 280,
		height: 600,
        margins: '5 5 5 5',
        layout: 'accordion',
        layoutConfig: {
            animate: true
        },
        defaults: {
            bodyStyle: 'padding: 10px'
        }
	});

	earth.on('kmlLoaded', function(t, kmlObject) {
		// can not set timeslider to whole timerange of kml placemarks
		// timespan is empty
        //var timespan = this.earth.getTime().getControl().getExtents();
        //this.earth.getTime().setTimePrimitive(timespan);

        // cache the place marks in javascript
        // walking through kml on the fly (during annotate()) to change colors is too slow
        this.placemarks = [];
        var placemarks = earth.earth.getFeatures().getFirstChild().getFeatures().getChildNodes();
        for(var i = 0; i < placemarks.getLength(); i++) {
        	var item = placemarks.item(i);
        	if (!item.getTimePrimitive()) {
                continue;
            }
        	this.placemarks.push({
        		begin: new Date(item.getTimePrimitive().getBegin().get()),
        		end: new Date(item.getTimePrimitive().getEnd().get()),
        		color: item.getStyleSelector().getIconStyle().getColor()
        	});
        }
        earth.setLoading(false);
    });

	earth.on('earthLoaded', function(){
        earth.getEarth().getNavigationControl().setVisibility(earth.getEarth().VISIBILITY_HIDE);
       // earth.getEarth().getTime().getControl().setVisibility(earth.getEarth().VISIBILITY_HIDE);

        earth.setLoading(true);
		earth.fetchKml(href);
		earth.findLocation('Amsterdam');

		// Add panels
        earth_options.add(earth.getKmlPanel());
        earth_options.add(earth.getLocationPanel());
        earth_options.add(earth.getLayersPanel());
        earth_options.add(earth.getOptionsPanel());
        earth_options.doLayout();
        win3.addTool({
			type: 'gear',
			tooltip: 'Options',
			handler: function() {
				earth_options.show();
			}
		});
	});

	win3 = Ext.create('Ext.window.Window', {
		width : 500,
		height : 500,
		x: 840,
		y: 20,
		closable: false,
        collapsible: true,
		title : 'GPS',
		layout: 'fit',
		maximizable: true,
		items: [earth]
	});
	win3.show();

	(function ( Popcorn ) {

		  var i = 0,
		      createDefaultContainer = function( context, id ) {

		        var ctxContainer = context.container = document.createElement( "div" ),
		            style = ctxContainer.style,
		            media = context.media;

		        var updatePosition = function() {
		          var position = context.position();
		          // the video element must have height and width defined
		          style.fontSize = "18px";
		          style.width = media.offsetWidth + "px";
		          style.top = 10 + "px";
		          style.left = 10 + "px";

		          setTimeout( updatePosition, 10 );
		        };

		        ctxContainer.id = id || Popcorn.guid();
		        style.position = "absolute";
		        style.color = "yellow";
		        style.textShadow = "black 2px 2px 6px";
		        style.fontWeight = "bold";
		        style.textAlign = "left";

		        updatePosition();

		        context.media.parentNode.appendChild( ctxContainer );

		        return ctxContainer;
		      };

		  /**
		   * Subtitle popcorn plug-in
		   * Displays a subtitle over the video, or in the target div
		   * Options parameter will need a start, and end.
		   * Optional parameters are target and text.
		   * Start is the time that you want this plug-in to execute
		   * End is the time that you want this plug-in to stop executing
		   * Target is the id of the document element that the content is
		   *  appended to, this target element must exist on the DOM
		   * Text is the text of the subtitle you want to display.
		   *
		   * @param {Object} options
		   *
		   * Example:
		     var p = Popcorn('#video')
		        .subtitle({
		          start:            5,                 // seconds, mandatory
		          end:              15,                // seconds, mandatory
		          text:             'Hellow world',    // optional
		          target:           'subtitlediv',     // optional
		        } )
		   *
		   */

		  Popcorn.plugin( "annotation" , {

		      manifest: {
		        about: {
		          name: "Popcorn Annotation Plugin",
		          version: "0.1",
		          author: "Stefan Verhoeven",
		          website: "http://www.nlesc.nl/"
		        },
		        options: {
		          start: {
		            elem: "input",
		            type: "text",
		            label: "Start"
		          },
		          end: {
		            elem: "input",
		            type: "text",
		            label: "End"
		          },
		          target: "subtitle-container",
		          text: {
		            elem: "input",
		            type: "text",
		            label: "Text"
		          }
		        }
		      },

		      _setup: function( options ) {
		        var newdiv = document.createElement( "div" );

		        newdiv.id = "subtitle-" + i++;
		        newdiv.style.display = "none";

		        // Creates a div for all subtitles to use
		        ( !this.container && ( !options.target || options.target === "subtitle-container" ) ) &&
		          createDefaultContainer( this );

		        // if a target is specified, use that
		        if ( options.target && options.target !== "subtitle-container" ) {
		          // In case the target doesn't exist in the DOM
		          options.container = document.getElementById( options.target ) || createDefaultContainer( this, options.target );
		        } else {
		          // use shared default container
		          options.container = this.container;
		        }

		        document.getElementById( options.container.id ) && document.getElementById( options.container.id ).appendChild( newdiv );
		        options.innerContainer = newdiv;

		        options.showSubtitle = function() {
		          options.innerContainer.innerHTML = options.text || "";
		        };
		      },
		      /**
		       * @member subtitle
		       * The start function will be executed when the currentTime
		       * of the video  reaches the start time provided by the
		       * options variable
		       */
		      start: function( event, options ){
		        options.innerContainer.style.display = "inline";
		        options.showSubtitle( options, options.text );
		      },
		      /**
		       * @member subtitle
		       * The end function will be executed when the currentTime
		       * of the video  reaches the end time provided by the
		       * options variable
		       */
		      end: function( event, options ) {
		        options.innerContainer.style.display = "none";
		        options.innerContainer.innerHTML = "";
		      },

		      _teardown: function ( options ) {
		        options.container.removeChild( options.innerContainer );
		      }

		  });

		})( Popcorn );

	Ext.define('Esc.popcorn.Video', {
		extend: 'Ext.Component',
		alias: 'widget.popcorn',
        initComponent: function() {
        	var defConfig = {
	            url: null,
	            startDate: null,
        	};
        	Ext.applyIf(this, defConfig);
        	this.callParent(arguments);
        },
        onResize: function(width, height, oldWidth, oldHeight) {
            if (oldWidth == undefined && oldHeight == undefined) {
             //   return;
            }
            // resize video tag
			this.pop.media.width = width;
			this.pop.media.height = height;
        },
		afterRender: function() {
			var el = this.getEl();
			var vid = this.vid = el.createChild({
				tag: 'video',
				preload: 'auto',
				autobuffer: null,
				controls: null,
			});

			// add video sources
			this.url.forEach(function(u) {
				vid.createChild({
					tag: 'source',
					src: u
				});
			});

			this.pop = Popcorn(vid.dom);
			//this.pop.controls(false);
		},
		remove: function() {
			this.pop.destroy();
			this.callParent(arguments);
		}
	});

	var win4 = Ext.create('Ext.window.Window', {
		width : 500,
		height : 500,
		x: 1360,
		y: 20,
		closable: false,
		collapsible: true,
		title: 'Video',
		layout: 'fit',
		maximizable: true,
		items: [{
			xtype: 'popcorn',
			startDate: initDates[0],
			url: ["92968607.mp4", "92968607.webm"]
		}]
	});
	win4.show();
});
</script>
</head>
<body>
<h1>TODO</h1>
<ul>
<li>integrate annotations store into panels, so changes/zooming auto-updates</li>
<li>Make annotations clickable/resize/moveable in timeline</li>
<li>Add icon/text to annotation in timeline</li>
<li>Add focus+context zooming</li>
</ul>
</body>
</html>