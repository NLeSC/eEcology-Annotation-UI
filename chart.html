<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Extjs - Chart</title>
<link rel="stylesheet" href="extjs/resources/css/ext-all.css"
    type="text/css"></link>
<link rel="stylesheet" type="text/css" href="ext-js-google-earth-api/Ext.ux.GEarthPanel-1.3.css" />
<style>
.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.x.axis path {
  display: none;
}

.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.focus {
  fill: none;
  stroke: red;
  stroke-width: 1px;
}

svg {
  background: white;
}

.annotation rect {
  opacity: 0.3;
}

rect.pane {
  cursor: move;
  fill: none;
  pointer-events: all;
}
.play {
  background-image: url(famfamfam_silk_icons/icons/control_play.png) !important;
}

.pause {
  background-image: url(famfamfam_silk_icons/icons/control_pause.png) !important;
}

.rewind {
  background-image: url(famfamfam_silk_icons/icons/control_rewind.png) !important;
}

video {
	background: black;
}

</style>
<script type="text/javascript" src="extjs/ext-all-dev.js"></script>
<script type="text/javascript" src="d3/d3.v3.min.js"></script>
<script type="text/javascript" src="https://www.google.com/jsapi"></script>
<!-- http://popcornjs.org/code/dist/popcorn-complete.min.js -->
<script type="text/javascript" src="popcorn-complete.js"></script>
<script type="text/javascript">
google.load("earth", "1");
google.load("maps", "2.xx");

Ext.Loader.setConfig({
    enabled: true,
    disableCaching: false, // uncomment to use firebug breakpoints
    paths: {
      'Ext.ux': 'ux/'
    }
});

Ext.require([
    'Ext.window.Window',
    'Ext.ux.GEarthPanel'
]);

Ext.useShims = true;

Ext.onReady(function() {
    Ext.define('Esc.d3.accelerometers', {
        extend: 'Ext.Component',
        alias: 'widget.accelchart',
        autoEl: {
            tag: 'svg'
        },
        initComponent: function() {
        	this.callParent(arguments);

            this.addEvents(
            	'focusDate'
            );
        },
        onResize: function(width, height, oldWidth, oldHeight) {
            if (oldWidth == undefined && oldHeight == undefined) {
                return;
            }
            this.draw();
        },
        draw: function() {
            var margin = {top: 5, right: 5, bottom: 50, left: 30},
            width = this.getWidth() - margin.left - margin.right,
            height = this.getHeight() - margin.top - margin.bottom;

            this.x.range([0, width]);
            this.y.range([height, 0]);

            var me = this;
            this.svg.select('rect.pane').attr('width', width).attr('height', height);

            this.svg.selectAll('path.line')
	            .attr("d", function(d) {
	                return me.line(d.values);
	            })
	            .style("stroke", function(d) {
	                return me.color(d.name);
	            })
	        ;

            this.svg.select('g.x.axis')
                .attr("transform", "translate(0," + height + ")")
                .call(this.xAxis);
            this.svg.select('g.y.axis').call(this.yAxis);
            this.svg.select('path.focus').attr("d", d3.svg.line()([[0, 0],[0, height]]));

            this.svg.selectAll(".legend rect").attr("x", width - 18);
            this.svg.selectAll(".legend text").attr("x", width - 24);
        },
        afterRender: function() {
            var me = this;
            var dom = this.getEl().dom;
            var margin = {top: 5, right: 5, bottom: 50, left: 30},
               width = this.getWidth() - margin.left - margin.right,
               height = this.getHeight() - margin.top - margin.bottom;

            var svg = this.svg = d3.select(dom).append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");;

            var x = this.x = d3.time.scale()
               .range([0, width]);

            var y = this.y = d3.scale.linear()
                .range([height, 0]);

            var color = this.color = d3.scale.category10();

            var xAxis = this.xAxis = d3.svg.axis()
                .scale(x)
                .orient("bottom");

            var yAxis = this.yAxis = d3.svg.axis()
                .scale(y)
                .orient("left");

            var line = this.line = d3.svg.line()
                .interpolate("basis")
                .x(function(d) { return x(d.date); })
                .y(function(d) { return y(d.g); });

            var data = [];
            for (var i = 0; i < 200; i++) {
                data.push({
                    date: new Date(new Date('2010-06-28T00:12:47Z').valueOf()+(5*60*1000*i)),
                    x: Math.random()*4-2,
                    y: Math.random()*4-2,
                    z: Math.random()*4-2,
                });
            }

            color.domain(d3.keys(data[0]).filter(function(key) { return key !== "date"; }));

            var cities = color.domain().map(function(name) {
              return {
                name: name,
                values: data.map(function(d) {
                  return {date: d.date, g: +d[name]};
                })
              };
            });

            x.domain(d3.extent(data, function(d) { return d.date; }));
            y.domain([
              d3.min(cities, function(c) { return d3.min(c.values, function(v) { return v.g; }); }),
              d3.max(cities, function(c) { return d3.max(c.values, function(v) { return v.g; }); })
            ]);

            this.data = data;
            this.cities = cities;

            svg.append("g")
                .attr("class", "x axis");

            svg.append("g")
                .attr("class", "y axis")
              .append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 6)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .text("g-force (m/s²)");

            var legend = svg.selectAll(".legend")
            .data(color.domain())
              .enter().append("g")
                .attr("class", "legend")
                .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

            legend.append("rect")
                .attr("width", 18)
                .attr("height", 18)
                .style("fill", color);

            legend.append("text")
                .attr("y", 9)
                .attr("dy", ".35em")
                .style("text-anchor", "end")
                .text(function(d) { return d; });

            var city = svg.selectAll(".city")
                .data(cities)
                .enter().append("g")
                    .attr("class", "city");

	        city.append("path")
	            .attr("class", "line")
            ;

            // zoomer rect which captures mouse drags and mouse wheel events
            var zoomer = this.svg.append('rect')
                .attr('class', 'pane')
                .attr('width', width)
                .attr('height', height)
                .on("mouseover", function() { me.focus.style("display", null); })
                .on("mouseout", function() {
                	me.up('window').setTitle('Accelerometers');
                    me.focus.style("display", "none");
                })
                .on("mousemove", this.onMouseMove.bind(this))
                // focus line + zoom dont go together because the compete over mousemove event
                //.call(d3.behavior.zoom().x(x).on("zoom", this.draw.bind(this)))
            ;

            this.focus = svg.append("path")
              .attr("class", "focus")
              .style("display", "none")

            this.draw();
        },
        onMouseMove: function() {
            var xp0 = d3.mouse(d3.event.target)[0];
            var x0 = this.x.invert(xp0);
            this.dateFocus(x0);
            this.fireEvent('focusDate', x0);
        },
        dateFocus: function(date) {
            var bisectDate = d3.bisector(function(d) { return d.date; }).left;
            var i = bisectDate(this.data, date, 1);
            if (i == 0 || i >= this.data.length) {
            	return;
            }
            var d0 = this.data[i - 1];
            var d1 = this.data[i];
            var d = date - d0.date > d1.date - date ? d1 : d0;
            this.focus.attr("transform", "translate("+ this.x(date) +",0)").style("display", null);
            this.up('window').setTitle('Accelerometers '+d.date+', x:'+d3.round(d.x, 5)+', y:'+d3.round(d.y, 5)+', z:'+d3.round(d.z, 5));
        }
    });

	Ext.define('Esc.d3.temperature', {
		extend: 'Ext.Component',
		alias: 'widget.tempchart',
		autoEl: {
            tag: 'svg'
        },
        initComponent: function() {
            this.callParent(arguments);

            this.addEvents(
                'focusDate'
            );
        },
        onResize: function(width, height, oldWidth, oldHeight) {
            if (oldWidth == undefined && oldHeight == undefined) {
                return;
            }
            this.draw();
        },
        draw: function() {
            var margin = {top: 5, right: 5, bottom: 50, left: 30},
            width = this.getWidth() - margin.left - margin.right,
            height = this.getHeight() - margin.top - margin.bottom;

            this.x.range([0, width]);
            this.y.range([height, 0]);

            this.svg.select('rect.pane').attr('width', width).attr('height', height);
            this.svg.select('path.line').attr('d', this.line);
            this.svg.select('g.x.axis')
                .attr("transform", "translate(0," + height + ")")
                .call(this.xAxis);
            this.svg.select('g.y.axis').call(this.yAxis);
            this.svg.select('path.focus').attr("d", d3.svg.line()([[0, 0],[0, height]]));
        },
        afterRender: function() {
        	var me = this;
        	var dom = this.getEl().dom;
        	var margin = {top: 5, right: 5, bottom: 50, left: 30},
        	   width = this.getWidth() - margin.left - margin.right,
        	   height = this.getHeight() - margin.top - margin.bottom;

        	var svg = this.svg = d3.select(dom).append("g")
    			.attr("transform", "translate(" + margin.left + "," + margin.top + ")");;

			var x = this.x = d3.time.scale()
			   .range([0, width]);

			var y = this.y = d3.scale.linear()
			    .range([height, 0]);

			var xAxis = this.xAxis = d3.svg.axis()
			    .scale(x)
			    .orient("bottom");

			var yAxis = this.yAxis = d3.svg.axis()
			    .scale(y)
			    .orient("left");

			var line = this.line = d3.svg.line()
			    .interpolate("basis")
    			.x(function(d) { return x(d.date); })
	       		.y(function(d) { return y(d.temperature); });


			var data = [];
			for (var i = 0; i < 400; i++) {
			    data.push({
			    	date: new Date(new Date('2010-06-28T00:12:47Z').valueOf()+(5*60*1000*i)),
			    	temperature: Math.random()*40-10
			    });
			}

			x.domain(d3.extent(data, function(d) { return d.date; }));
			y.domain(d3.extent(data, function(d) { return d.temperature; }));

			svg.datum(data);
			this.data = data;

			svg.append("g")
			    .attr("class", "x axis");

			svg.append("g")
			    .attr("class", "y axis")
			  .append("text")
			    .attr("transform", "rotate(-90)")
			    .attr("y", 6)
			    .attr("dy", ".71em")
			    .style("text-anchor", "end")
			    .text("Temperature (ºC)");

			svg.append("path")
                .attr("class", "line");

            // zoomer rect which captures mouse drags and mouse wheel events
            var zoomer = this.svg.append('rect')
                .attr('class', 'pane')
                .attr('width', width)
                .attr('height', height)
                .on("mouseover", function() { me.focus.style("display", null); })
                .on("mouseout", function() {
                	me.up('window').setTitle('Temperature');
                    me.focus.style("display", "none");
                })
                .on("mousemove", this.onMouseMove.bind(this))
                // focus line + zoom dont go together because the compete over mousemove event
                //.call(d3.behavior.zoom().x(x).on("zoom", this.draw.bind(this)))
            ;

            this.focus = svg.append("path")
		      .attr("class", "focus")
		      .style("display", "none")
	        ;

			this.draw();
        },
        onMouseMove: function() {
        	var xp0 = d3.mouse(d3.event.target)[0];
        	var x0 = this.x.invert(xp0);
            this.dateFocus(x0);
            this.fireEvent('focusDate', x0);
        },
        dateFocus: function(date) {
            var bisectDate = d3.bisector(function(d) { return d.date; }).left,
            i = bisectDate(this.data, date, 1),
            d0 = this.data[i - 1],
            d1 = this.data[i],
            d = date - d0.date > d1.date - date ? d1 : d0;
            this.focus.attr("transform", "translate("+ this.x(date) +",0)").style("display", null);
            this.up('window').setTitle('Temperature '+d.date+', '+d3.round(d.temperature, 5)+'&deg;C');
        }
	});

	Ext.define('Esc.eEcology.Annotation', {
		extend: 'Ext.data.Model',
		fields: [{
			name: 'type'
		}, {
			name: 'start', type: 'date'
		}, {
			name: 'end', type: 'date'
		}, {
			name: 'color'
		}]
	});

	Ext.define('Esc.eEcology.AnnotationStore', {
		extend: 'Ext.data.Store',
		model: 'Esc.eEcology.Annotation'
	});

	var store = Ext.create('Esc.eEcology.AnnotationStore', {
		listeners: {
			dataChanged: function() {
				console.log('Data changed', arguments);
			},
            add: function() {
                console.log('add', arguments);
            },
            remove: function() {
                console.log('remove', arguments);
            },
            clear: function() {
                console.log('clear', arguments);
            },
			update: function(s, r, o) {
				if (o == Ext.data.Model.COMMIT) {
                    var start = new Date(r.data.start);
                    var end = new Date(r.data.end);
				    // TODO draw annotation backgrounds on charts
				    var charts = [
                        Ext.ComponentQuery.query('tempchart')[0],
                        Ext.ComponentQuery.query('accelchart')[0]
				    ];
				    charts.forEach(function(c) {
                        var x = c.x(start);
				    	var w = c.x(end)-x;
				    	// TODO add updating
			            c.svg.insert("g", ':first-child').attr('class', 'annotation').append('rect')
			                .attr('class', r.data.type)
			                .attr('width', w)
			                .attr('height', c.getHeight())
			                .attr('x', x)
			                .attr('y', 0)
			                .style('fill', r.data.color)
			            ;
				    });
				    var video = Ext.ComponentQuery.query('popcorn')[0];
				    //var s = (video.startDate - start) / 1000;
				    //var e = (video.startDate - end) / 1000;
					var s = 0;
					var e = 120;
				    var sub = video.pop.annotation({
				    	start: s,
				    	end: e,
				    	text: r.data.type,
				    });
				    sub.container.style.color = r.data.color;

				    earth.annotate(r);
				}
			}
		}
	});

	var rowEditing = Ext.create('Ext.grid.plugin.RowEditing', {
        clicksToMoveEditor: 1,
        autoCancel: false
    });

	// There is no datetime field in ExtJS, so use a textfield with ISO 8601 validator
	Ext.apply(Ext.form.field.VTypes, {
	    //  vtype validation function
	    datetime: function(val, field) {
	        return Ext.Date.parse(val, 'c', true) != null;
	    },
	    // vtype Text property: The error text to display when the validation function returns false
	    datetimeText: 'Not a valid date.  Must be in the ISO 8601 date format.',
	    // vtype Mask property: The keystroke filter mask
	    datetimeMask: /[\d\.,-:+TZ]/
	});
	Ext.define('Esc.form.field.DateTime', {
		extend: 'Ext.form.field.Text',
		alias: 'widget.datetimefield',
		vtype: 'datetime',
		valueToRaw: function(value) {
			if (value === undefined) {
				return value;
			}
            return value.toISOString();
		},
		rawToValue: function(raw) {
            return new Date(raw);
		}
	});

    var agrid = Ext.create('Ext.grid.Panel', {
        store: store,
        columns: [{
        	text: 'Type', dataIndex: 'type',
        	editor: {xtype: 'combo', allowBlank: false, store:['flying', 'sitting', 'walking', 'floating']}
        }, {
            text: 'Start', dataIndex: 'start', flex: 1,
            xtype: 'datecolumn', format: 'c',
            editor: {xtype: 'datetimefield', allowBlank: false}
        }, {
            text: 'End', dataIndex: 'end', flex: 1,
            xtype: 'datecolumn', format: 'c',
            editor: {xtype: 'datetimefield', allowBlank: false}
        }, {
            text: 'Color', dataIndex: 'color',
            renderer: function(v, m) {
            	m.style = 'background:'+v+';';
            	return v;
            },
            editor: {xtype: 'textfield', allowBlank: false}
        }],
        plugins: [rowEditing],
        tbar: [{
            text: 'Add annotation',
            handler : function() {
                rowEditing.cancelEdit();

                // Create a model instance
                var r = Ext.create('Esc.eEcology.Annotation', {
                	type: 'walking',
                    start: new Date('2010-06-28T00:12:47Z'),
                    end: new Date('2010-06-28T06:12:47Z'),
                    color: 'rgb(180, 112, 197)'
                });

                store.insert(0, r);
                rowEditing.startEdit(0, 0);
            }
        }],
        listeners: {
            edit: function(editor, e) {
                e.record.commit();
            }
        },
    });

    var awin = Ext.create('Ext.window.Window', {
        x: 20,
        y: 540,
        width : 1840,
        height : 300,
		closable: false,
        title : 'Annotations',
        layout: 'fit',
        maximizable: true,
        items: [agrid],
        dockedItems: [{
            xtype: 'toolbar',
            dock: 'bottom',
            items: [{
            	xtype: 'component',
            	id: 'current_time',
            	html: new Date('2010-06-28T00:12:47Z').toISOString()
            }, {
            	xtype: 'slider',
            	width: '80%',
            	increment: 1000*60*5, // 5 minutes
            	value: new Date('2010-06-28T00:12:47Z').valueOf(),
            	minValue: new Date('2010-06-28T00:12:47Z').valueOf(),
                maxValue: new Date('2010-06-28T17:43:09Z').valueOf(),
            	tipText: function(thumb) {
            		return new Date(thumb.slider.getValue()).toISOString();
            	},
            	listeners: {
            		change: function(slider, newValue) {
            			var date = new Date(newValue);

            			Ext.getCmp('current_time').update(date.toISOString());

            			Ext.ComponentQuery.query('accelchart')[0].dateFocus(date);
            			Ext.ComponentQuery.query('tempchart')[0].dateFocus(date);

            			var earth_time = earth.getEarth().getTime();
            			var t = earth_time.getTimePrimitive();
            			if (t.getType() != 'KmlTimeSpan') {
            				t = earth_time.getControl().getExtents();
            			}
            			t.getEnd().set(date.toISOString());
                        earth_time.setTimePrimitive(t);

                        var video = Ext.ComponentQuery.query('popcorn')[0];
                        var newct = video.pop.duration() * (newValue-slider.minValue) / (slider.maxValue-slider.minValue);
                        console.log(newct);
                        video.pop.currentTime(newct);
            		}
            	}
            }, {
                iconCls: 'play',
                toolTip: 'Play',
                handler: function() {
                    var pop = Ext.ComponentQuery.query('popcorn')[0].pop;
                    pop.play();
                }
            }, {
                iconCls: 'pause',
                toolTip: 'Pause',
                handler: function() {
                    var pop = Ext.ComponentQuery.query('popcorn')[0].pop;
                    pop.pause();
                }
            }, {
                iconCls: 'rewind',
                toolTip: 'Rewind',
                handler: function() {
                    var pop = Ext.ComponentQuery.query('popcorn')[0].pop;
                    pop.currentTime(0);
                    Ext.ComponentQuery.query('slider')[0].setValue(0);
                }
            }]
        }]
    })
    awin.show();

    var win = Ext.create('Ext.window.Window', {
        x: 20,
        y: 20,
        width : 800,
        height : 240,
		closable: false,
        title : 'Temperature',
        layout: 'fit',
        maximizable: true,
        items: [{
            xtype: 'tempchart',
            listeners: {
            	focusDate: function(date) {
            		Ext.ComponentQuery.query('accelchart')[0].dateFocus(date);
            	}
            }
        }]
    })
    win.show();

    var win2 = Ext.create('Ext.window.Window', {
    	x: 20,
        y: 280,
        width : 800,
        height : 240,
		closable: false,
        title : 'Accelerometers',
        layout: 'fit',
        maximizable: true,
        items: [{
            xtype: 'accelchart',
            listeners: {
                focusDate: function(date) {
                    Ext.ComponentQuery.query('tempchart')[0].dateFocus(date);
                }
            }
        }]
    })
    win2.show();

	// Use https://github.com/pymonger/ext-js-google-earth-api
	earth = Ext.create('Ext.ux.GEarthPanel', {
		earthLayers: {
            LAYER_BUILDINGS: true,
            LAYER_TERRAIN: true
        },
        earthOptions: {
            setStatusBarVisibility: false,
            setAtmosphereVisibility: true,
            setMouseNavigationEnabled: true
        },
        annotate: function(record) {
	        var begin = record.data.start;
	        var end = record.data.end;
	        // Convert rgb(rr, gg, bb) to FFbbggrr
            var color = d3.rgb(record.data.color);
	        var abgr = 'ff'+color.b.toString(16)+color.g.toString(16)+color.r.toString(16);

            // Only the first placemark is shown initially
            // to see all placemarks the time has to be set to a time span
        	// can't set time to whole extent during fetchkml callback
        	// so do it here
            var timespan = this.earth.getTime().getControl().getExtents();
            this.earth.getTime().setTimePrimitive(timespan);

            Ext.Array.forEach(this.placemarks, function(placemark) {
            	var ts_begin = placemark.begin;
            	var ts_end = placemark.end;
            	if (
                        (ts_begin>=begin && ts_begin<=end) ||
                        (ts_end>=begin && ts_end<=end) ||
                        (ts_begin<=begin && ts_end>=end)
                ) {
                    placemark.color.set(abgr);
                }
            });
        }
	});
	var href = 'http://145.100.61.27/workspace4/ExtJS-Cesium/S355_museumplein.kml';

	var earth_options = Ext.create('Ext.window.Window', {
		title: 'Google Earth options',
		width: 280,
		height: 600,
        margins: '5 5 5 5',
        layout: 'accordion',
        layoutConfig: {
            animate: true
        },
        defaults: {
            bodyStyle: 'padding: 10px'
        }
	});

	earth.on('kmlLoaded', function(t, kmlObject) {
		// can not set timeslider to whole timerange of kml placemarks
		// timespan is empty
        //var timespan = this.earth.getTime().getControl().getExtents();
        //this.earth.getTime().setTimePrimitive(timespan);

        // cache the place marks in javascript
        // walking through kml on the fly (during annotate()) to change colors is too slow
        this.placemarks = [];
        var placemarks = earth.earth.getFeatures().getFirstChild().getFeatures().getChildNodes();
        for(var i = 0; i < placemarks.getLength(); i++) {
        	var item = placemarks.item(i);
        	if (!item.getTimePrimitive()) {
                continue;
            }
        	this.placemarks.push({
        		begin: new Date(item.getTimePrimitive().getBegin().get()),
        		end: new Date(item.getTimePrimitive().getEnd().get()),
        		color: item.getStyleSelector().getIconStyle().getColor()
        	});
        }
        earth.setLoading(false);
    });

	earth.on('earthLoaded', function(){
        earth.getEarth().getNavigationControl().setVisibility(earth.getEarth().VISIBILITY_HIDE);
       // earth.getEarth().getTime().getControl().setVisibility(earth.getEarth().VISIBILITY_HIDE);

        earth.setLoading(true);
		earth.fetchKml(href);
		earth.findLocation('Amsterdam');

		// Add panels
        earth_options.add(earth.getKmlPanel());
        earth_options.add(earth.getLocationPanel());
        earth_options.add(earth.getLayersPanel());
        earth_options.add(earth.getOptionsPanel());
        earth_options.doLayout();
        win3.addTool({
			type: 'gear',
			tooltip: 'Options',
			handler: function() {
				earth_options.show();
			}
		});
	});

	win3 = Ext.create('Ext.window.Window', {
		width : 500,
		height : 500,
		x: 840,
		y: 20,
		closable: false,
		title : 'GPS',
		layout: 'fit',
		maximizable: true,
		items: [earth]
	});
	win3.show();

	(function ( Popcorn ) {

		  var i = 0,
		      createDefaultContainer = function( context, id ) {

		        var ctxContainer = context.container = document.createElement( "div" ),
		            style = ctxContainer.style,
		            media = context.media;

		        var updatePosition = function() {
		          var position = context.position();
		          // the video element must have height and width defined
		          style.fontSize = "18px";
		          style.width = media.offsetWidth + "px";
		          style.top = 10 + "px";
		          style.left = 10 + "px";

		          setTimeout( updatePosition, 10 );
		        };

		        ctxContainer.id = id || Popcorn.guid();
		        style.position = "absolute";
		        style.color = "yellow";
		        style.textShadow = "black 2px 2px 6px";
		        style.fontWeight = "bold";
		        style.textAlign = "left";

		        updatePosition();

		        context.media.parentNode.appendChild( ctxContainer );

		        return ctxContainer;
		      };

		  /**
		   * Subtitle popcorn plug-in
		   * Displays a subtitle over the video, or in the target div
		   * Options parameter will need a start, and end.
		   * Optional parameters are target and text.
		   * Start is the time that you want this plug-in to execute
		   * End is the time that you want this plug-in to stop executing
		   * Target is the id of the document element that the content is
		   *  appended to, this target element must exist on the DOM
		   * Text is the text of the subtitle you want to display.
		   *
		   * @param {Object} options
		   *
		   * Example:
		     var p = Popcorn('#video')
		        .subtitle({
		          start:            5,                 // seconds, mandatory
		          end:              15,                // seconds, mandatory
		          text:             'Hellow world',    // optional
		          target:           'subtitlediv',     // optional
		        } )
		   *
		   */

		  Popcorn.plugin( "annotation" , {

		      manifest: {
		        about: {
		          name: "Popcorn Annotation Plugin",
		          version: "0.1",
		          author: "Stefan Verhoeven",
		          website: "http://www.nlesc.nl/"
		        },
		        options: {
		          start: {
		            elem: "input",
		            type: "text",
		            label: "Start"
		          },
		          end: {
		            elem: "input",
		            type: "text",
		            label: "End"
		          },
		          target: "subtitle-container",
		          text: {
		            elem: "input",
		            type: "text",
		            label: "Text"
		          }
		        }
		      },

		      _setup: function( options ) {
		        var newdiv = document.createElement( "div" );

		        newdiv.id = "subtitle-" + i++;
		        newdiv.style.display = "none";

		        // Creates a div for all subtitles to use
		        ( !this.container && ( !options.target || options.target === "subtitle-container" ) ) &&
		          createDefaultContainer( this );

		        // if a target is specified, use that
		        if ( options.target && options.target !== "subtitle-container" ) {
		          // In case the target doesn't exist in the DOM
		          options.container = document.getElementById( options.target ) || createDefaultContainer( this, options.target );
		        } else {
		          // use shared default container
		          options.container = this.container;
		        }

		        document.getElementById( options.container.id ) && document.getElementById( options.container.id ).appendChild( newdiv );
		        options.innerContainer = newdiv;

		        options.showSubtitle = function() {
		          options.innerContainer.innerHTML = options.text || "";
		        };
		      },
		      /**
		       * @member subtitle
		       * The start function will be executed when the currentTime
		       * of the video  reaches the start time provided by the
		       * options variable
		       */
		      start: function( event, options ){
		        options.innerContainer.style.display = "inline";
		        options.showSubtitle( options, options.text );
		      },
		      /**
		       * @member subtitle
		       * The end function will be executed when the currentTime
		       * of the video  reaches the end time provided by the
		       * options variable
		       */
		      end: function( event, options ) {
		        options.innerContainer.style.display = "none";
		        options.innerContainer.innerHTML = "";
		      },

		      _teardown: function ( options ) {
		        options.container.removeChild( options.innerContainer );
		      }

		  });

		})( Popcorn );

	Ext.define('Esc.popcorn.Video', {
		extend: 'Ext.Component',
		alias: 'widget.popcorn',
//		autoEl: {
//            tag: 'video'
//        },
        initComponent: function() {
        	var defConfig = {
	            url: null,
	            startDate: null,
        	};
        	Ext.applyIf(this, defConfig);
        	this.callParent(arguments);
        },
        onResize: function(width, height, oldWidth, oldHeight) {
            if (oldWidth == undefined && oldHeight == undefined) {
             //   return;
            }
            // resize video tag
			this.pop.media.width = width;
			this.pop.media.height = height;
        },
		afterRender: function() {
			var el = this.getEl();
			var vid = this.vid = el.createChild({
				tag: 'video',
				preload: 'auto',
				autobuffer: null,
				controls: null,
			});

			// add video sources
			this.url.forEach(function(u) {
				vid.createChild({
					tag: 'source',
					src: u
				});
			});

			this.pop = Popcorn(vid.dom);
			//this.pop.controls(false);
		},
		remove: function() {
			this.pop.destroy();
			this.callParent(arguments);
		}
	});

	var win4 = Ext.create('Ext.window.Window', {
		width : 500,
		height : 500,
		x: 1360,
		y: 20,
		closable: false,
		title: 'Video',
		layout: 'fit',
		maximizable: true,
		items: [{
			xtype: 'popcorn',
			startDate: new Date('2010-06-28T00:12:47Z'),
			url: ["92968607.mp4", "92968607.webm"]
		}]
	});
	win4.show();
});
</script>
</head>
<body>
</body>
</html>